[["wprowadzenie-do-c.html", "Rozdział 1 Wprowadzenie do C", " Skrypt dla początkujących Poznaj C w ciągu kilku godzin Patryk Tomaszewski Rozdział 1 Wprowadzenie do C Język C wydaje się najbardziej znanym językiem programowania na całym świecie, a przynajmniej ze swojej nazwy. Na całym świecie kursy informatyki używają go jako język referencyjny i niewykluczone, że dla najbardziej licznej grupy ludzi, pierwszym od którego zaczyna się naukę programowania wraz z Pythonem i Javą. Ten skrypt oczywiście nie obejmuje wszystkiego, ale kieruje się zasadą 80/20. Jest skoncentrowany na większości zagadnień (wspomniane 80), przy czym bardziej złożone tematy optymalizuje pod względem czasu nauki (wspomniane 20). C nie służy tylko studentom do opanowania umiejętności programowania. Nie jest językiem akademickim. Mógłbym rzec, że nie jest to najłatwiejszy język, należy raczej do niskopoziomowych języków programowania, które słyną z poziomu trudności. Obecnie C jest szeroko stosowany w urządzeniach wbudowanych (ang. embedded devices) oraz serwerach internetowych, działających w linuksowym systemie operacyjnym. Samo jądro Linux (ang. Linux kernel) jest zbudowane przy użyciu C co również oznacza, że jest obecny na wszystkich urządzeniach z Androidem. Mógłbym rzec, że kod w C jest używany w dużej części świata, a to już jest wystarczająco spektakularne, by zainspirować się do jego poznania. W czasie, gdy został opracowany przez Dennisa Ritchiego w laboratoriach Bella, był uważany za język wysokiego poziomu, ponieważ kod w niezmienionej formie można było uruchomić na różnych komputerach. Obecnie definicja wysokopoziomowości języka, a szczególnie przenośności kodu, oznacza możliwość uruchomienia programu np. przy użyciu Node.js lub Python napisanego na komputerze Mac, w systemie Windows czy Linux. Dlatego aktualnie uznaje się, że C jest językiem niskiego poziomu. Ale nie zawsze tak było. C wniósł do świata język, który był prosty do implementacji i posiadał kompilator, który nie trudno było przenieść na różne maszyny. C jest kompilowanym językiem programowania, takim jak Go, Java, Swift lub Rust. Aktualnie popularne języki takie jak Python, Ruby lub JavaScript nazywa się językami interpretowanymi. Różnica polega na generacji pliku binarnego, który może być bezpośrednio uruchomiony i dystrybuowany. Nie mniej jednak możliwość generacji pliku wykonywalnego (ang. executable file) nie świadczy o tym, że język nie jest interpretowany. W C nie ma automatycznej dealokacji, czyli tak zwanego odśmiecania pamięci (ang. garbage collection). Oznacza to oczywiście, że sami musimy zarządzać alokacją pamięci RAM (ang. random-access memory). Wymaga to dużej uwagi, ale również sprawia, że C jest idealny do pisania programów dla urządzeń wbudowanych (ang. embedded devices), takich jak Arduino. W C nie ukrywa się złożoności i możliwości maszyny. Masz dużą swobodę, kiedy oczywiście wiesz, co możesz zrobić. A teraz przedstawiam pierwszy program C, nazywa się ,,Witaj, świecie!’’ #include &lt;stdio.h&gt; int main(void) { printf(&quot;Hello, World!&quot;); } Kod źródłowy (ang. source code) programu rozpoczyna się od importu biblioteki stdio (nazwa oznacza standardową std bibliotekę wejścia-wyjścia io). Ta biblioteka daje nam dostęp do funkcji wejścia/wyjścia. Sam C jest bardzo niewielkim językiem, a wszystko co nie jest jego częścią, jest zapewniane przez biblioteki. Wiele bibliotek jest rozwijanych i udostępnianych w sieci przez niezależnych programistów. Natomiast standardowe biblioteki (ang. standard libraries) są wbudowane w kompilator, tj. stdio. W stdio można znaleźć funkcję printf(). Ta funkcja umieszczona jest w obrębie funkcji main(). Funkcja main() jest punktem wejścia (ang. entry point) każdego programu w C. Ale co to właściwie jest funkcja? Funkcja w swoim obrębie zawiera kod programu, który korzystając z przekazanych argumentów, oddzielonych przecinkami, wykonuje określone zadania i zwraca pojedynczą wartość lub nic nie zwraca. Funkcja main() nie otrzymuje argumentów i zwraca liczbę całkowitą. Identyfikujemy to za pomocą słowa kluczowego void jako argumentu i słowa kluczowego int dla wartości zwracanej. Kod potrzebny funkcji do wykonania jej operacji zawiera się w nawiasach klamrowych. Jak widać, funkcja printf() jest napisana inaczej. Nie ma zdefiniowanej wartości zwracanej, a my przekazujemy jako argument ciąg tekstowy w cudzysłowie. Nie podajemy typu argumentu. To dlatego, że jest to wywołanie funkcji. Gdzieś w bibliotece stdio funkcja printf jest zdefiniowana jako int printf(const char *format, ...); Nie musisz teraz rozumieć co to oznacza, ale taka jest definicja tej funkcji. Kiedy wywołujemy printf(\"Witaj,świecie!\"); to właśnie tam jest uruchamiana funkcja. Funkcja main() zostaje wywołana przez system operacyjny podczas uruchomienia programu. Jak uruchamiamy program C? Jak wspomniałem, C jest językiem kompilowanym. Aby uruchomić program, musimy go najpierw skompilować. Każdy komputer z systemem Linux lub macOS ma już wbudowany kompilator C. W każdym razie, po otwarciu okna terminala i wpisaniu gcc powinno nam zwrócić błąd informujący, że nie określono żadnego pliku: Oznacza to, że kompilator C jest zainstalowany i możemy go używać. Teraz zajmiemy się wpisaniem powyższego programu do pliku hello.c. Możesz użyć dowolnego edytora, ale dla uproszczenia użyję edytora nano z poziomu wiersza poleceń (ang. command line): Wpisz program: Teraz naciśnij Ctrl+X, aby wyjść: Potwierdź, naciskając klawisz y: Wpisz nazwę pliku hello.c, a następnie naciśnij klawisz Enter, aby potwierdzić nazwę pliku: To wszystko, powinniśmy teraz wrócić do terminala. Teraz: gcc hello.c -o hello Program nie powinien zwrócić żadnych błędów: Powinien wygenerować plik wykonywalny hello. Teraz: ./hello aby go uruchomić: Jeśli jednak się nie uruchomił, a tak właśnie będzie w systemie Linuks, wpisz: chmod +x hello i spróbuj ponownie. Dodałem ./ do nazwy programu, aby poinformować terminal, że polecenie znajduje się w bieżącym folderze. Teraz, jeśli wywołasz ls -al hello, zobaczysz, że rozmiar tego programu wynosi tylko 12 KB: Jest to jedna z zalet C. Jest niezrównanie zoptymalizowany ale to jest tylko jeden z powodów przez które jest tak eksploatowany w urządzeniach wbudowanych (ang. embedded devices), które mają bardzo ograniczoną ilość zasobów. "],["typy-zmiennych.html", "Rozdział 2 Typy zmiennych 2.1 Zmienne typu całkowitego (ang. integer numbers) 2.2 Kwalifikator unsigned 2.3 Problem przepełnienia (ang. overflow) 2.4 Ostrzeżenia (ang. warnings) kompilatora spowodowane niejawną konwersją (ang. implicit conversion) 2.5 Liczby zmiennoprzecinkowe (ang. floating point numbers)", " Rozdział 2 Typy zmiennych C to język statycznie typowany co oznacza, że każda zmienna jest określonego typu i jest on znany w czasie kompilacji, w przeciwieństwie do pracy ze zmiennymi w Pythonie, JavaScript, PHP i innymi interpretowanymi językami. Podczas ustalania zmiennej w C musisz określić typ zmiennej. W poniższym przykładzie inicjujemy zmienną age o typie int: int age; Nazwa zmiennej może zawierać dowolną wielką lub małą literę, znaki podkreślenia i cyfry, ale nie może zaczynać się od cyfr. Przykładowo AGE i Age10 są poprawnymi nazwami zmiennych, natomiast 1age już nie. Możesz także zainicjować zmienną podczas jej deklaracji określając wartość początkową: int age = 37; Po zadeklarowaniu zmiennej można jej używać w dalszym kodzie programu. Można zmieniać jej wartość w dowolnym momencie, używając na przykład operatora =, przykładowo age = 100; (pod warunkiem, że nowa wartość jest tego samego typu). Dlatego w poniższym przykładzie: #include &lt;stdio.h&gt; int main(void) { int age = 0; age = 37.2; printf(&quot;%u&quot;, age); } kompilator wyświetli ostrzeżenie w czasie kompilacji i skonwertuje liczbę dziesiętną na wartość całkowitą. Wbudowane typy danych w języku C to int, char, short, long, float, double, long i double. Dowiemy się o nich więcej w kolejnych rozdziałach. W tym momencie nie przejmuj się jeszcze znaczeniem %u. Jest to formatowanie podanego argumentu i zostanie to wyjaśnione później. 2.1 Zmienne typu całkowitego (ang. integer numbers) C zapewnia nam następujące typy zmiennych całkowitych: char int short long W czasie kodowania w większości będziesz używał int do przechowywania liczb całkowitych. W pewnych przypadkach wybierzesz jednen z pozostałych typów. Typ char jest powszechnie używany do przechowywania liter w kodowaniu ASCII. Równie dobrze sprawdza się dla liczb całkowitych, których użycie zawiera się w zakresie od \\(-128\\) do \\(127\\) (np. w arduino, nie ma to jednak większego sensu dla komputerów stacjonarnych). Zajmuje przestrzeń co najmniej 1 bajtu. Natomiast int zajmuje co najmniej 2 bajty, short zajmuje co najmniej 2 bajty, long zajmuje co najmniej 4 bajty. Jak widać po tym opisie, nie ma gwarancji ile bajtów w pamięci zajmuje dany typ zmiennej, a powyższy opis przedstawia tylko zakres, którego możemy być pewni. Problem w tym wypadku polega przede wszystkim na zależności typów danych od implementacji i architektury. Norma ANSI C określa minimalne ilości batów zajmowanych przez każdy typ (jakiego minimalnego zakresu wartości możemy się spodziewać po danym typie). Jeśli programujesz w C na Arduino to może już zauważyłeś, że różne płytki (z innymi mikrokontrolerami) mogą mieć różne zakresy dla typu int (jak i kilku pozostałych typów liczb). Na płytce Arduino Uno int przechowuje wartości od \\(-32 768\\) do \\(32 767\\), czyli ma długość 2-bajtów, a w Arduino MKR 1010 int zajmuje przestrzeń 4 bajtów (zakres od \\(-2 147 483 648\\) do \\(2 147 483 647\\)). Jak widać to całkiem spora różnica. Na wszystkich płytklach Arduino typ short zajmuje 2 bajty (od \\(-32 768\\) do \\(32 767\\)), long 4 bajty (od \\(-2 147 483 648\\) do \\(2 147 483 647\\)). 2.2 Kwalifikator unsigned Do wszystkich typów danych liczbowych z poprzedniego rozdziału można dodać słowo kluczowe unsigned co sprawi, że zakres będzie rozpoczynał się od 0. Taka liczba zawsze będzie nieujemna. W wielu przypadkach może to mieć sens. unsigned char w zakresie od 0 do przynajmniej \\(255\\) unsigned int w zakresie od 0 do przynajmniej \\(65,535\\) unsigned short w zakresie od 0 do przynajmniej \\(65,535\\) unsigned long w zakresie od 0 do przynajmniej \\(4,294,967,295\\) 2.3 Problem przepełnienia (ang. overflow) Mając na uwadze wszystkie wspomniane limity wypada zadać sobie pytanie: Jak możemy się upewnić, że nasze liczby nie przekroczą swoich limitów? Najpierw jednak odpowiedzmy sobie na pytanie: Co się stanie, jeśli przekroczymy limit? Jeśli masz liczbę nieujemną typu unsigned int o wartości 255 i inkrementujesz ją, otrzymasz wartość 256. Zgodnie z oczekiwaniami. Jeśli masz liczbę nieujemną typu unsigned char o wartości 255 i zwiększysz ją o 1 (jak w poprzednim przykładzie), otrzymasz wartość 0. Po pokonaniu górnego limitu jakim jest 255 liczba tego typu resetuje się, zaczynając od dolnego limitu wartości. Jeśli masz liczbę typu unsigned char z zapisaną liczbą 255 i dodasz do niej 10, otrzymasz liczbę 9: #include &lt;stdio.h&gt; int main(void) { unsigned char j = 255; j = j + 10; printf(&quot;%u&quot;, j); /* 9 */ } Natomiast gdy twoja zmienna jest oznakowanego typu (bez słowa kluczowego unsigned) i przekroczysz granicę danego typu, np. dodasz 10 do zmiennej typu char, której wartość była równa górnemu limitowi, to wypisując ją na ekran za pomocą formatu %u (formatowanie liczby unsigned) ujrzymy na wyjściu coś, co nazywamy niezdefiniowanym zachowaniem (ang. undefined behavior). Zasadniczo funkcja printf() wypisze ogromną liczbę, która w zależności od implamentacji i architektury może się różnić: #include &lt;stdio.h&gt; int main(void) { char j = 127; j = j + 10; printf(&quot;%u&quot;, j); /* 4294967177 */ } Innymi słowy, C nie chroni cię przed przekroczeniem limitów danego typu. Musisz sam się tym zająć. W przypadku C ,,niezdefiniowane zachowanie’’ (ang. undefined behavior) oznacza, że zachowanie nie jest opisane w standardzie, a to co dokładnie się stanie nie musi być opisane w dokumentacji danej implementacji C. 2.4 Ostrzeżenia (ang. warnings) kompilatora spowodowane niejawną konwersją (ang. implicit conversion) Kiedy zadeklarujesz zmienną i zainicjujesz ją z niewłaściwą wartością, kompilator gcc powinien wypisać ostrzeżenie: #include &lt;stdio.h&gt; int main(void) { char j = 1000; } hello.c:4:11: warning: implicit conversion from &#39;int&#39; to &#39;char&#39; changes value from 1000 to -24 [-Wconstant-conversion] char j = 1000; ~ ^~~~ 1 warning generated. również w przypadku bezpośredniego przypisania: #include &lt;stdio.h&gt; int main(void) { char j; j = 1000; } Nie dzieje się tak jednak w przypadku operacji arytmetycznych, np. +=: #include &lt;stdio.h&gt; int main(void) { char j = 0; j += 1000; } 2.5 Liczby zmiennoprzecinkowe (ang. floating point numbers) Typy zmiennoprzecinkowe mogą reprezentować znacznie większy zakres wartości niż liczby całkowite, a także mogą reprezentować ułamki, czego nie są w stanie liczby całkowite. Liczby zmiennoprzecinkowe reprezentuje się w notacji naukowej (ang. scientific notation). Jest to zapis dziesiętny, mała lub wielka litera E oraz wykładnik (potęgi liczby 10). Możesz więc zapisać liczbę zmiennoprzecinkową jak poniżej: \\(1.29e-3\\) \\(-2.3e+5\\) i na inne pozornie dziwne sposoby. Następujące typy: float double long double są używane do reprezentowania liczb rzeczywistych z przecinkiem dziesiętnym. Wszystkie reprezentują zarówno liczby dodatnie, jak i ujemne. Minimalne wymagania dla dowolnej implementacji C są takie, że float ma reprezentować zakres od \\(10 ^ {-37}\\) do \\(10 ^ {+ 37}\\) i zwykle jest implementowana przy użyciu 32 bitów. Liczba typu double może reprezentować większy zakres liczb, a long double jeszcze większy. Dokładne zakresy i rozmiary liczb zmiennoprzecinkowych, podobnie jak u liczb całkowitych, zależą od implementacji. Na współczesnym komputerze liczba zmiennoprzecinkowa jest reprezentowana za pomocą 32 bitów, ma precyzję 24 bitów (znak \\(+/-\\) oraz mantysa), a 8 bitów służy do kodowania wykładnika potęgowego. Liczba double jest reprezentowana w 64 bitach, z dokładnością do 53 bitów znaczących i 11 bitów do kodowania potęgi. Typ long double jest reprezentowany w 80 bitach, ma precyzję 64 bitów znaczących oraz 15 bitów do kodowania potęgi. Aby na konkretnym komputerze sprawdzić rozmiar typów w bajtach można oczywiście napisać program: #include &lt;stdio.h&gt; int main(void) { printf(&quot;char size: %lu bytes\\n&quot;, sizeof(char)); printf(&quot;int size: %lu bytes\\n&quot;, sizeof(int)); printf(&quot;short size: %lu bytes\\n&quot;, sizeof(short)); printf(&quot;long size: %lu bytes\\n&quot;, sizeof(long)); printf(&quot;float size: %lu bytes\\n&quot;, sizeof(float)); printf(&quot;double size: %lu bytes\\n&quot;, sizeof(double)); printf(&quot;long double size: %lu bytes\\n&quot;, sizeof(long double)); } którego wynik może być następujący: char size: 1 bytes int size: 4 bytes short size: 2 bytes long size: 8 bytes float size: 4 bytes double size: 8 bytes long double size: 16 bytes "],["stałe-ang.-constants.html", "Rozdział 3 Stałe (ang. constants)", " Rozdział 3 Stałe (ang. constants) Stała jest deklarowana podobnie jak pozostałe zmienne ale sama w sobie nie jest typem. Każda zmienna może być poprzedzona słowem kluczowym const i zawsze w czasie deklaracji należy podać jej wartość. Jak poniżej: const int age = 37; Jest to całkowicie poprawna składnia, jednak często deklaruje się stałe dużymi literami: const int AGE = 37; Jest to tylko konwencja, ale taka, która może znacznie pomóc podczas czytania lub pisania programu w języku C (poprawia czytelność). Gdy zadeklarujesz nazwy stałych wielkimi literami unikniesz pomyłek. Zwykle zapis wielkimi literami oznacza stałą, małymi literami zmienną. Nazewnictwo stałych podlega tym samym regułom, które były przedstawione dla nazw zmiennych: może zawierać dowolną wielką lub małą literę, może zawierać cyfry i znak podkreślenia, ale nie może zaczynać się od cyfry. Innym sposobem definiowania stałych jest użycie tej składni: #define AGE 37 W tym przypadku nie deklarujesz typu, nie używasz również znaku równości \\(=\\) i nie zapisujesz średnika na końcu. Kompilator C wywnioskuje typ na podstawie podanej wartości w czasie kompilacji. "],["operatory.html", "Rozdział 4 Operatory 4.1 Operatory arytmetyczne 4.2 Operatory relacji 4.3 Operatory logiczne 4.4 Złożone operatory przypisania 4.5 Operator trójoperandowy (ang. ternary operator) 4.6 sizeof 4.7 Priorytety operatorów", " Rozdział 4 Operatory C oferuje nam szeroką gamę operatorów, których możemy używać do operowania na danych. W C wyróżniamy następujące rodzaje operatorów: operatory arytmetyczne (ang. arithmetic operators) operatory relacji (ang. comparison operators) operatory logiczne (ang. logical operators) złożone operatory przypisania (ang. compound assignment operators) operatory bitowe (ang. bitwise operators) operatory wyłuskania (ang. pointer operators) operatory selekcji (ang. structure operators) operatory różne (ang. miscellaneous operators) W tej sekcji opiszę te operatory na przykładach używając dwóch nazw zmiennych: a i b. Operatory bitowe, selekcji i wyłuskania zostaną opisane w dalszych sekcjach niniejszego skryptu. 4.1 Operatory arytmetyczne Operatory arytmetyczne służą do wykonywania operacji arytmetycznych, czyli mnożenia, dzielenia, dodawania, odejmowania itp. Występują w tej grupie również takie operatory jak operator inkrementacji i dekrementacji oraz operatory znaku wartości. Operatory można podzielić na operatory dwuargumentowe i operatory jednoargumentowe, np. *, /, % są dwuargumentowe, natomiast ++, -- są jednoargumentowe ale operatory +, - należą do obu tych grup. Operatory dwuargumentowe działają przy użyciu dwóch operandów: Operator Nazwa Przykład = przypisanie a = b + dodawanie a + b - odejmowanie a - b * mnożenie a * b / dzielenie a / b % reszta z dzielenia a % b Operatory jednoargumentowe przyjmują tylko jeden operand: Operator Nazwa Przykład + plus jednoargumentowy +a - minus jednoargumentowy -a ++ inkrementacja a++ lub ++a -- dekrementacja a-- lub --a Różnica między a++, a ++a polega na tym, że a++ zwiększa wartość zmiennej po jej użyciu, natomiast ++a inkrementuje zmienną przed jej użyciem. Na przykład: int a = 2; int b; b = a++ /* b = 2, a = 3 */ b = ++a /* b = 4, a = 4 */ To samo dotyczy operatora dekrementacji. 4.2 Operatory relacji Operator Nazwa Przykład == równe a == b != różne a != b &gt; większe a &gt; b &lt; mniejsze a &lt; b &gt;= większe lub równe a &gt;= b &lt;= mniejsze lub równe a &lt;= b 4.3 Operatory logiczne Operator Nazwa Przykład ! NOT !a &amp;&amp; AND a &amp;&amp; b || OR a || b Operatory te świetnie sprawdzają się do pracy z wartościami logicznymi. 4.4 Złożone operatory przypisania Operatory te upraszczają wykonanie przypisania z jednocześnym wykonaniem operacji arytmetycznej: Operator Nazwa Przykład Wyrażenie równoważne += dodawanie a += b a = a + b -= odejmowanie a -= b a = a - b *= mnożenie a *= b a = a * b /= dzielenie a /= b a = a / b %= reszta z dzielenia a %= b a = a % b Jak widać zapis w kolumnie ,,przykład’’ jest krótszy niż w kolumnie ,,wyrażenie równoważne’’ i moim zdaniem łatwiejszy do przeczytania. 4.5 Operator trójoperandowy (ang. ternary operator) Operator trójskładnikowy (inna nazwa) jest jedynym operatorem w C, który współpracuje z 3 operandami i jest to najkrótszy sposób na wyrażenie warunkowe. Wygląda on tak: &lt;condition&gt; ? &lt;expression&gt; : &lt;expression&gt; gdzie &lt;condition&gt; to wyrażenie sprowadzające się do wartości logicznej (prawda lub fałsz), a &lt;expression&gt; to instrukcja. Przykład: a ? b : c Jeśli z a wynika wartość logiczna true, wówczas wykonywana jest instrukcja b, w przeciwnym razie c. Operator trójoperandowy jest funkcjonalnie taki sam jak if / else, ale jest krótszy i może zostać wstawiony do wyrażenia, ponieważ zwraca wynik instrukcji b lub c. 4.6 sizeof Operator sizeof przyjmuje jeden parametr i zwraca jego rozmiar w bajtach. Możesz przekazać zmienną, a nawet typ. Przykładowe użycie: #include &lt;stdio.h&gt; int main(void) { int age = 37; printf(&quot;%ld\\n&quot;, sizeof(age)); printf(&quot;%ld&quot;, sizeof(int)); } 4.7 Priorytety operatorów Przy wszystkich operatorach (również nieopisanych do tej pory) musimy zwracać uwagę na ich priorytet podczas ich użycia w jednym wyrażeniu. Przykładowo: int a = 2; int b = 4; int c = b + a * a / b - a; Jaka jest wartość zmiennej c? Czy dodawanie jest wykonywane przed mnożeniem i dzieleniem? Istnieje określony zbiór zasad, które odpowiedzą na te pytania. Priorytet to nic innego jak pierwszeństwo w wykonywaniu działań. Poniżej zapisałem działania pod względem pierwszeństwa rosnąco: = operator przypisania + i - operator dodawania/odejmowania * i / operator mnożenia/dzielenia + i - liczba dodatnia/ujemna (operator znaku liczby) Jak widać jest to zgodne z intuicją z jednym zastrzeżeniem, operatory dodatkowo podlegają łączności, która mówi o tym, że działania o tym samym priorytecie zawsze wykonywane są od lewej do prawej (z wyjątkiem operatorów jednoargumentowych i przypisania). W linii: int c = b + a * a / b - a; najpierw wykonane zostanie działanie a * a / b, które ze względu na ten sam priorytet wykona się od lewej do prawej co znaczy, że najpierw wystąpi mnożenie a * a, później / b, w tym wypadku \\(2 * 2 = 4\\) oraz \\(4/4 = 1\\). Następnie sumowanie i odejmowanie \\(4 + 1 - 2\\). Wartość \\(c\\) wynosi więc \\(3\\). Używając określonego typu wypada również uważać podczas zapisu działań. Jeśli zamiast zapisu a * a / b użylibyśmy a / b * a (co powinno dać ten sam rezultat) to byśmy się zdziwili, ponieważ a / b, czyli \\(2 / 4\\) będzie równe \\(0\\) dla typu int (obcina część ułamkową liczby). Chciałbym jeszcze dodać, że możesz używać nawiasów, dzięki temu działania zawsze wykonają się w takiej kolejności jakiej będziejsz chciał oraz uczynią wyrażenie łatwiejszym do odczytania i zrozumienia. Nawiasy () zawsze mają wyższy priorytet, wyższy niż cokolwiek innego. Powyższe przykładowe wyrażenie można przepisać jako: int c = b + ((a * a) / b) - a; i nie musimy już więcej myśleć o priorytetach. "],["instrukcje-warunkowe-ang.-conditionals.html", "Rozdział 5 Instrukcje warunkowe (ang. conditionals) 5.1 if 5.2 switch", " Rozdział 5 Instrukcje warunkowe (ang. conditionals) Każdy język programowania zapewnia programistom możliwość zdefiniowania warunków w zależności od których zostaną wykonane różne instrukcje. C zapewnia nam na to dwa sposoby. Pierwszym z nich jest instrukcja if z opcjonalnym blokiem else, a drugim jest instrukcja switch. 5.1 if W instrukcji if możesz sprawdzić, czy warunek jest prawdziwy, a następnie wykonać blok podany w nawiasach klamrowych: int a = 1; if (a == 1) { /* do something */ } Możesz dołączyć else aby wykonać inny blok, jeśli warunek okaże się fałszywy: int a = 1; if (a == 2) { /* do something */ } else { /* do something else */ } Uważaj przy tym na jedno, bardzo popularne źródło błędów, a mianowicie operator porównania == zawiera podwójny znak równości, a operator przypisania = pojedynczy. Zawsze używaj operatorów porównania w instrukcji warunkowej, aby uniknąć błędów. Podczas użycia operatora przypisania if będzie zawsze prawdziwe, gdy argument nie jest wartością \\(0\\), na przykład: int a = 0; if (a = 0) { /* never invoked */ } Dlaczego tak się dzieje? Ponieważ liczba \\(0\\) zawsze będzie równa fałszywej wartości logicznej. Wszystkie inne wartości liczbowe zostaja sprowadzone do wartości logicznej \\(1\\) (prawdy), w tym liczby ujemne. Instrukcja if nie sprowadza się do dwóch bloków kodu, nie ma ograniczenia co do liczby bloków, po każdym else może następować kolejny warunek if: int a = 1; if (a == 2) { /* do something */ } else if (a == 1) { /* do something else */ } else { /* do something else again */ } 5.2 switch W sytuacji gdy wykonanie odpowiednich bloków kodu zależeć będzie od dokładnej wartości zmiennej, konstrukcja if / else if / else stanie się mniej odpowiednia od konstrukcji switch. Możesz podać zmienną (ang. variable) jako warunek (ang. condition) i serię punktów wejścia (ang. entry points) dla każdej oczekiwanej wartości: int a = 1; switch (a) { case 0: /* do something */ break; case 1: /* do something else */ break; case 2: /* do something else */ break; } Na końcu każdego bloku obowiązkowo używamy słowa kluczowego break, w przeciwnym razie blok kodu kolejnego zapisanego przez nas case zostanie wykonany bez sprawdzenia warunku, itd. Ten efekt nazywamy ,,kaskadowym’’ i może być bardzo użyteczny w specyficznych przypadkach. Na końcu switch możesz dodać przypadek oznaczony jako default: int a = 1; switch (a) { case 0: /* do something */ break; case 1: /* do something else */ break; case 2: /* do something else */ break; default: /* handle all the other cases */ break; } Wykonany zostanie, gdy żaden z podanych warunków nie zostanie spełniony. "],["pętle-ang.-loops.html", "Rozdział 6 Pętle (ang. loops) 6.1 Pętla for 6.2 Pętla while 6.3 Pętla do while 6.4 Instrukcja break", " Rozdział 6 Pętle (ang. loops) C oferuje nam trzy sposoby wykonywania pętli: for, while , a także do while. Wszystkie pozwalają na iterację po tablicach, ale z kilkoma różnicami. Zobaczmy je szczegółowo. 6.1 Pętla for Pierwszym i prawdopodobnie najczęstszym sposobem wykonania pętli jest instrukcja for. Za pomocą słowa kluczowego for możemy zdefiniować reguły pętli z góry, a następnie napisać blok kodu, który będzie powtórzony wielokrotnie. Przykład: for (int i = 0; i &lt;= 10; i++) { /* instructions to be repeated */ } Blok (int i = 0; i &lt;= 10; i++) zawiera 3 części oddzielone średnikami o szczególnej specyfice: definicja zmiennej (int i = 0) bądź kilku tego samego typu (oddzielone przecinkami, nie średnikami) kryterium wyjścia (i &lt;= 10) inkrementację (i++) bądź operacje na zmiennych (oddzielone przecinkami, nie średnikami) Najpierw definiujemy zmienną, w tym przypadku o nazwie i. Nazwa i jest powszechnie używaną nazwą zmiennej typu int podczas iteracji w pętli, wraz z j dla zagnieżdżonych pętli (ang. nested loops). Zagnieżdzona pętla to po prostu pętla wewnątrz innej pętli. Takie nazewnictwo to tylko konwencja, która popularnie używana stanowi ważny składnik czytelności kodu. W naszym przykładzie zmienna i jest inicjalizowana wartością 0, następnie sprawdzany jest warunek i następuje pierwsze wykonanie bloku kodu. Po pierwszej iteracji wykonana zostaje część i++, sprawdzony zostaje warunek i &lt;= 10 i cały cykl powtarza się, aż dojdzie do liczby 10. Wewnątrz głównego bloku pętli można używać zmiennej i. Poniższy program wypisze 0 1 2 3 4 5 5 6 7 8 9 10: for (int i = 0; i &lt;= 10; i++) { /* instructions to be repeated */ printf(&quot;%u &quot;, i); } Pętle mogą również zaczynać się od innej liczby, która będzie zmniejszać się: for (int i = 10; i &gt; 0; i--) { /* instructions to be repeated */ } Można również zwiększać albo zmniejszać zmienną nie tylko o \\(1\\): for (int i = 0; i &lt; 1000; i = i + 30) { /* instructions to be repeated */ } 6.2 Pętla while Pętla while jest łatwiejsza do napisania niż for, ponieważ ta wymaga trochę więcej pracy z twojej strony. Zamiast definiować wszystkie dane pętli z góry podczas jej pisania, w tym wypadku zapisuje się jedynie sprawdzany warunek: while (i &lt; 10) { } W powyższym przykładzie zakładam, że zmienna i jest już zdefiniowana i zainicjowana odpowiednią wartością. Ta pętla stanie się pętlą nieskończoną jeśli nie modyfikujesz zmiennej i wewnątrz bloku pętli. Nieskończona pętla przydaje się w arduino, ale na komputerze zablokuje program, uniemożliwiając cokolwiek innego. Oto czego potrzebujesz do ,,poprawnej’’ pętli while: int i = 0; while (i &lt; 10) { /* do something */ i++; } Jest jeden wyjątek, w którym użycie nieskończonej pętli w programie komputerowym rzeczywiście ma sens i zobaczymy go za chwilę. Wcześniej pozwólcie, że przedstawię składnię pętli do while. 6.3 Pętla do while Mogą zdarzyć się sytuacje, w których niezależnie od jakiegokolwiek warunku blok kodu musi zostać wykonany, a spełnienie warunku sprawia, że należy ten blok kodu powtórzyć. Taka sytuację można zrealizować za pomocą do while. W pewnym sensie jest bardzo podobny do wcześniejszej pętli while: int i = 0; do { /* do something */ i++; } while (i &lt; 10); Blok zawierający komentarz /* do something */ jest wykonywany co najmniej raz, niezależnie od wyniku sprawdzenia warunku na dole. Następnie, dopóki zmienna i jest mniejsza niż 10, blok instrukcji jest powtarzany. 6.4 Instrukcja break We wszystkich pętlach C mamy możliwość natychmiastowego wyjścia z pętli w dowolnym momencie, niezależnie od warunków pętli. Odbywa się to za pomocą słowa kluczowego break. Jest to przydatne w wielu przypadkach. Na przykład: for (int i = 0; i &lt;= 10; i++) { if (i == 4 &amp;&amp; someVariable == 10) { break; } } Ta opcja wyjścia z pętli jest szczególnie interesująca i stosowana w przypadku pętli while (również do while), ponieważ pozornie nieskończone pętle można w ten sposób zakończyć. Przykład: int i = 0; while (1) { /* do something */ i++; if (i == 10) break; } Tego rodzaju pętle w C są dość powszechne, szczególnie w interaktywnych aplikacjach konsolowych. "],["tablice-ang.-arrays.html", "Rozdział 7 Tablice (ang. arrays)", " Rozdział 7 Tablice (ang. arrays) Tablica jest zmienną, która przechowuje szereg wartości. Każda wartość w tablicy w C musi być tego samego typu. Oznacza to, że będziesz mieć tablice wartości int, tablice wartości double itd. Możesz zdefiniować tablicę wartości int jak poniżej: int prices[5]; Zawsze musisz określić rozmiar tablicy. Standard C nie dostarcza implementacji dynamicznych tablic (w tym celu musisz użyć struktury danych, takiej jak lista wiązana). Możesz użyć bezpośrednio całkowitej nieujemnej wartości lub stałej, przykład: const int SIZE = 5; int prices[SIZE]; Możesz zainicjować tablicę w czasie jej deklaracji, w poniższy sposób: int prices[5] = { 1, 2, 3, 4, 5 }; Możesz odwoływać się do elementu w tablicy, używając nawiasów kwadratowych po nazwie zmiennej, za pomocą indeksu. Przykład: prices[0]; /* array item value: 1 */ prices[1]; /* array item value: 2 */ Możesz również przypisać poszczególne wartości po zdefiniowaniu tablicy (o ile nie zapiszesz jej ze słowem kluczowym const) w następujący sposób: int prices[5]; prices[0] = 1; prices[1] = 2; prices[2] = 3; prices[3] = 4; prices[4] = 5; lub bardziej praktycznie, z użyciem pętli: int prices[5]; for (int i = 0; i &lt; 5; i++) { prices[i] = i + 1; } Indeksy tablic zaczynają się od 0, więc tablica z 5 elementami, jak powyższa tablica, będzie zawierać elementy od prices[0] do prices[4]. To na co należy zwrócić uwagę w tablicach C jest to, że wszystkie elementy tablicy są przechowywane sekwencyjnie, czyli jeden po drugim w pamięci komputera. Nie jest to regułą w przypadku języków programowania wyższego poziomu. Inną interesującą rzeczą jest to, że nazwa zmiennej tablicy prices jest wskaźnikiem do pierwszego elementu tablicy. Więc może być używany jak zwykły wskaźnik zmiennej. Wskaźniki szczegółowo zostaną omówione w dalszej części. "],["tekstowy-typ-danych-ang.-string.html", "Rozdział 8 Tekstowy typ danych (ang. string)", " Rozdział 8 Tekstowy typ danych (ang. string) W C łańcuchy są specjalnym rodzajem tablicy: łańcuch jest tablicą wartości typu char: char name[7]; Co nieco już opisałem wcześniej o typie char, ale tak pokrótce, char jest powszechnie używany do przechowywania liter z tabeli kodu ASCII. Tekst można zainicjować tak, jak inicjuje się normalną tablicę: char name[7] = { &quot;F&quot;, &quot;l&quot;, &quot;a&quot;, &quot;v&quot;, &quot;i&quot;, &quot;o&quot; }; Ale znacznie wygodniej jest to robić z użyciem literału, tzn. wpisać ciąg znaków w cudzysłowie: char name[7] = &quot;Flavio&quot;; Tekst można wypisać w konsoli funkcją printf() za pomocą formatu %s: printf(&quot;%s&quot;, name); Ciekawy jestem czy zauważyłeś, że napis “Flavio” jest długości 6 znaków ale zdefiniowałem tablicę o długości 7. Dlaczego? Jest tak, ponieważ ostatni znak w ciągu musi być wartością \\(0\\) (ang. string terminator) i zawsze musimy go uwzględnić. Należy o tym pamiętać, szczególnie przy manipulowaniu łańcuchami. Mówiąc o manipulowaniu łańcuchami, istnieje jedna ważna standardowa biblioteka dostarczana przez C: string.h. Ta biblioteka jest niezbędna, ponieważ zakrywa wiele niskopoziomowych szczegółów dotyczących pracy z ciągami i zapewnia nam zestaw niezbędnych oraz przydatnych funkcji. Możesz załadować bibliotekę do swojego programu, dodając na górze: #include &lt;string.h&gt; Po dodaniu tego nagłówka, możesz używać: strcpy() do skopiowania ciągu znaków strcat() do połączenia ciągow znaków strcmp() do porównania dwóch ciągów znaków strncmp() do porównania pierwszych n znaków dwóch ciągów strlen() do obliczenia długości łańcucha i wielu, wielu innych funkcji. "],["wskaźniki-ang.-pointers.html", "Rozdział 9 Wskaźniki (ang. pointers)", " Rozdział 9 Wskaźniki (ang. pointers) Wskaźniki są jednym z najtrudniejszych elementów do opanowania w języku C, zwłaszcza jeśli dopiero zaczynasz programować, ale również gdy znasz jedynie języki programowania wyższego poziomu takie jak Python lub JavaScript. W tej części chcę przedstawić je w najprostszy, ale nie bezużyteczny sposób. Wskaźnik to zmienna, ale zawierająca adres bloku w pamięci. Kiedy deklarujesz liczbę całkowitą: int age = 37; to nie widzisz pod jakim adresem się ona znajduje i na tym poziomie użycia tak naprawdę nie musisz się tym przejmować. Używając operatora &amp; możesz uzyskać wartość adresu w pamięci do tej zmiennej: printf(&quot;%p&quot;, &amp;age); /* 0x7ffeef7dcb9c */ Użyłem formatu %p, ponieważ służy on głównie do wypisywania wartości adresów. Możemy przypisać adres do zmiennej wskaźnikowej: int *address = &amp;age; Pisząc int * address nie deklarujemy zmiennej całkowitej, ale wskaźnik do liczby całkowitej. Możemy użyć operatora wskaźnika *, aby uzyskać wartość zmiennej: int age = 37; int *address = &amp;age; printf(&quot;%u&quot;, *address); /* 37 */ Zapis *address w funkcji printf() oznacza użycie wartości zmiennej, na którą wskazuje ten wskaźnik. W tym przykładzie deklarujemy zmienną age i używamy wskaźnika do inicjalizacji wartości: int age; int *address = &amp;age; *address = 37; printf(&quot;%u&quot;, *address); /* 37 */ printf(&quot;%u&quot;, age); /* 37 */ Podczas kodowania w C przekonasz się, że cała masa rzeczy jest zbudowana na podstawie tej prostej koncepcji. Upewnij się więc, że zapoznałeś się z koncepcją wskaźników, uruchamiając przynajmniej powyższe przykłady samodzielnie. Wskaźniki zmuszają nas do myślenia o adresach pamięci i sposobie organizacji danych, a to świetny sposób na rozwinięcie w sobie myślenia abstrakcyjnego. A teraz wróćmy do tablic. Kiedy deklarujesz tablicę: int prices[3] = { 5, 4, 3 }; Zmienna prices jest tak naprawdę wskaźnikiem do pierwszego elementu tablicy. Sprawdźmy to: printf(&quot;%u&quot;, *prices); /* 5 */ Ciekawe i warte uwagi jest to, że możemy dostać się do drugiego elementu tablicy dodając 1 do wskaźnika price: printf(&quot;%u&quot;, *(prices + 1)); /* 4 */ oraz analogicznie do wszystkich innych wartości. Możemy w ten sposób wykonywać operacje na tekście, ponieważ te są również tablicami. Wskaźniki mają wiele innych zastosowań jak przekazywanie referencji do obiektu lub nawet funkcji. W ten sposób można uniknąć zużywania większej ilości zasobów, np. kopiowania dużych obiektów. "],["funkcje-ang.-functions.html", "Rozdział 10 Funkcje (ang. functions)", " Rozdział 10 Funkcje (ang. functions) Funkcje są sposobem w jaki możemy podzielić nasz kod na podprogramy, które możemy: nazwać wywołać w każdym miejscu kodu Już od pierwszego programu “Hello, World!” korzystasz z funkcji C: #include &lt;stdio.h&gt; int main(void) { printf(&quot;Hello, World!&quot;); } Funkcja main() jest bardzo ważną funkcją, ponieważ jest punktem wejścia (ang. entry point) dla programu C. Oto kolejna funkcja: void doSomething(int value) { printf(&quot;%u&quot;, value); } Funkcje mają 4 ważne właściwości: mają nazwę, więc możemy je później wywołać (ang. call) określają typ wartości zwracanej mogą mieć argumenty blok kodu funkcji zawiera się w nawiasach klamrowych Blok kodu to zestaw instrukcji, które są wykonywane za każdym razem, gdy wywołujemy funkcję. Jeśli funkcja nie zwraca żadnej wartości używa się słowa kluczowego void przed nazwą funkcji. W innym przypadku należy określić typ zwracanej wartości funkcji (int dla liczby całkowitej, float dla wartości zmiennoprzecinkowej, char dla znaku ASCII, char * dla tekstu itd.). Nie jest możliwe zwrócenie kilku wartości z funkcji (ale jest na to sposób, o którym później). Funkcja może mieć argumenty. Jeśli jednak ich nie potrzebujemy, w nawiasach wstawiamy void lub nic nie wstawiamy, jak poniżej: void doSomething(void) { /* ... */ } W takim przypadku, gdy wywołujemy funkcję, wywołujemy ją bez żadnych argumentów: doSomething(); Jeśli przewidujemy jeden parametr to określamy jego typ i nazwę, jak poniżej: void doSomething(int value) { /* ... */ } Kiedy wywołujemy funkcję, przekazujemy ten parametr w nawiasach, jak poniżej: doSomething(3); Możemy mieć wiele parametrów i rozdzielamy je przecinkiem, zarówno w deklaracji jak i w wywołaniu: void doSomething(int value1, int value2) { /* ... */ } doSomething(3, 4); Parametry są przekazywane poprzez ich kopię. Oznacza to, że jeśli zmodyfikujesz value1 wewnątrz funkcji, jej wartość zostanie zmodyfikowana lokalnie. Natomiast wartość poza funkcją, która została przekazana w wywołaniu, nie zmieni się. Inaczej będzie w przypadku gdy przekażesz wskaźnik jako parametr, możesz dowolnie zmodyfikować wartość zmiennej, ponieważ masz bezpośredni dostęp do adresu w pamięci. W czystym C nie można zdefiniować wartości domyślnej parametru. W C++ można to zrobić (podobnie jak w języku Arduino), ale nie w C. Pamiętaj o definicji funkcji przed jej wywołaniem, w przeciwnym razie kompilator wyświetli ostrzeżenie i błąd: gcc hello.c -o hello; ./hello hello.c:13:3: warning: implicit declaration of function &#39;doSomething&#39; is invalid in C99 [-Wimplicit-function-declaration] doSomething(3, 4); ^ hello.c:17:6: error: conflicting types for &#39;doSomething&#39; void doSomething(int value1, char value2) { ^ hello.c:13:3: note: previous implicit declaration is here doSomething(3, 4); ^ 1 warning and 1 error generated. Otrzymane ostrzeżenie dotyczy deklaracji o której już wspomniałem. Natomiast błąd jest z tym powiązany. Gdy C ,,nie widzi’’ deklaracji funkcji przed wywołaniem, musi przyjąć założenie, że funkcja po prostu zwraca int (mimo, że de fakto jeszcze nie istnieje). Natomiast nasza funkcja zwraca wartość void (czyli nic), stąd ten błąd. Jeśli zmienisz definicję funkcji na: int doSomething(int value1, int value2) { printf(&quot;%d %d\\n&quot;, value1, value2); return 1; } dostaniesz tylko ostrzeżenie, ale nie błąd (!): gcc hello.c -o hello; ./hello hello.c:14:3: warning: implicit declaration of function &#39;doSomething&#39; is invalid in C99 [-Wimplicit-function-declaration] doSomething(3, 4); ^ 1 warning generated. W każdym razie pamiętaj, aby zadeklarować funkcję przed jej użyciem. Przenieś funkcję wyżej w pliku kodu lub dodaj prototyp funkcji, najlepiej w osobnym pliku nagłówkowym. Wewnątrz funkcji możesz deklarować zmienne. void doSomething(int value) { int doubleValue = value * 2; } Zmienna jest tworzona w miejscu wywołania funkcji i jest niszczona po zakończeniu funkcji. Nie jest widoczna z zewnątrz. Wewnątrz pisanej funkcji możesz wywołać ją samą! Nazywa się to rekurencją i oferuje specyficzne możliwości. "],["operacje-wejściawyjścia-ang.-inputoutput-operations.html", "Rozdział 11 Operacje wejścia/wyjścia (ang. Input/Output operations) 11.1 printf() 11.2 scanf()", " Rozdział 11 Operacje wejścia/wyjścia (ang. Input/Output operations) C jest stosunkowo niewielkim językiem programowania, a sam ,,rdzeń’’ C nawet nie obejmuje jakichkolwiek funkcji wejścia/wyjścia (I/O). Oczywiście nie jest to coś wyjątkowego i występującego tylko w C. Dość często sam rdzeń języka nie zapewnia operacji wejścia/wyjścia. W przypadku C operacje wejścia/wyjścia są dostarczane przez bibliotekę standardową C w postaci zestawu funkcji zdefiniowanych w pliku nagłówkowym stdio.h. Możesz zaimportować tę bibliotekę, używając: #include &lt;stdio.h&gt; na poczatku pliku C. Ta biblioteka zapewnia nam między innymi funkcje: printf() - wypisanie sformatowanego tekstu na standardowe wyjście scanf() - wczytanie tekstu ze standardowego wejścia w określonym formacie sscanf() - wczytanie tekstu z innego ciągu tekstowego w określonym formacie fgets() - wczytanie tekstu z pliku fprintf() - wypisanie sformatowanego tekstu do pliku Zanim opiszę, jak działają te funkcje, chcę poświęcić chwilę strumieniom we/wy. Mamy 3 rodzaje strumieni we/wy w C: stdin (standardowe wejście) stdout (standardowe wyjście) stderr (standardowe wyjście błędów) Dzięki funkcjom I/O zawsze pracujemy ze strumieniami. Strumień to interfejs wysokiego poziomu, który może reprezentować urządzenie lub plik. Z punktu widzenia C nie mamy żadnej różnicy w czytaniu z pliku lub czytaniu z wiersza poleceń: w każdym przypadku jest to strumień we/wy. To jedna z rzeczy, o których należy zawsze pamiętać. Niektóre funkcje są zaprojektowane do pracy z określonym strumieniem, na przykład printf(), którego używamy do wypisania znaków na standardowe wyjście. Używając bardziej ogólnego odpowiednika fprintf(), możemy określić, do którego strumienia pisać. 11.1 printf() Funkcja printf() to oczywiście jedna z pierwszych funkcji, którą będziesz namiętnie używać podczas nauki programowania w języku C. W najprostszej formie użycia przekazujesz tekst (w cudzysłowie): printf(&quot;hey!&quot;); a program wypisze zawartość ciągu na ekranie. Możesz wypisać wartość zmiennej. Jest to jednak trochę upierdliwe, ponieważ musisz zapisać formatowanie w postaci znaków specjalnych, które różnią się w zależności od typu zmiennej. Na przykład %d dla liczb całkowitych: int age = 37; printf(&quot;My age is %d&quot;, age); Funkcja nie ogranicza się jednak do wypisywania pojedynczej zmiennej, ale całych zdań ze zmiennymi: int age_yesterday = 37; int age_today = 36; printf(&quot;Yesterday my age was %d and today is %d&quot;, age_yesterday, age_today); Co ciekawe mamy możliwość podania nieograniczonej liczby zmiennych oddzielonych przecinkami ale to już jest poza zakresem tego ,,tutoriala’’. Jest wiele specyfikatorów formatu, ale najważniejsze do zapamiętania na tę chwilę to: %c dla char %s dla tekstowego typu danych %d dla liczb całkowitych %f dla liczb zmiennoprzecinkowych %p dla wskaźników Możemy użyć znaków specjalnych w printf() takich jak \\n, który oznacza przejście do nowego wiersza. Poniżej zawieram najważniesze z nich: literał definicja \\r powrót kursora (karetki) do początku wiersza \\n znak nowego wiersza \\\" cudzysłów \\' apostrof \\\\ ukośnik wsteczny (backslash) \\t tabulacja pozioma 11.2 scanf() Funkcja printf() jest używana do wypisania tekstu w konsoli. Chcę również przedstawić funkcję do wprowadzania danych, aby można było powiedzieć, że omówiłem operacje wejścia/wyjścia. Funkcja scanf() służy do pobrania wartości wpisanej przez użytkownika uruchamiającego program z poziomu wiersza poleceń. Najpierw jednak powinniśmy zdefiniować zmienną, która będzie przechowywać wartość, którą otrzymamy z wejścia: int age; Następnie zapisujemy scanf() zawsze z przynajmniej 2 argumentami. Podajemy format (typ) zmiennej i adres (!) do zmiennej: scanf(&quot;%d&quot;, &amp;age); Jeśli chcesz zczytać tekst jako dane wejściowe to pamiętaj, że nazwa zmiennej jest wskaźnikiem do pierwszego znaku, więc nie potrzebujesz operatora &amp;: char name[20]; scanf(&quot;%s&quot;, name); Poniżej przedstawiam mały program do ,,wyłudzania danych osobowych’’, który używa zarówno printf() jak i scanf(): #include &lt;stdio.h&gt; int main(void) { char name[20]; printf(&quot;Enter your name: &quot;); scanf(&quot;%s&quot;, name); printf(&quot;you entered %s&quot;, name); } "],["operacje-na-plikach.html", "Rozdział 12 Operacje na plikach 12.1 fprintf() 12.2 fgetc() 12.3 fputc() 12.4 Operacje na plikach binarnych", " Rozdział 12 Operacje na plikach W przypadku operacji plikowych należy użyć wskaźnika do FILE, który pozwoli programowi utrzymać dostęp do pliku. Na przykład: FILE *fp; Aby otworzyć plik, musisz użyć funkcji fopen(), która zwraca wskaźnik FILE*. Po otwarciu pliku można użyć wskaźnika FILE*, aby umożliwić kompilatorowi wykonywanie funkcji wejścia i wyjścia. FILE *fopen(const char *filename, const char *mode); Jeśli używasz literału tekstowego jako ścieżki do pliku, musisz pamiętać, aby używać dwóch ukośników odwrotnych zamiast jednego. Za pomocą ukośnika odwrotnego definiuje się znak ucieczki, taki jak \\t (wstawienie tabulatora). Użycie podwójnych ukośników odwrotnych \\\\ powoduje wstawienie znaku \\, który należy użyć podczas zapisywania ścieżki do pliku. Tak właśnie traktowane są łańcuchy w C i C++. W przypadku pobierania ścieżki do pliku z konsoli oczywiście nie zapisuje się ukośników podwójnie. Dozwolone tryby dla fopen(): r - otwarcie pliku do odczytu w - otwarcie pliku do zapisu (plik nie może już istnieć) a - otwarcie pliku do zapisu (kursor ustawiony na koniec pliku) r+ - otwarcie pliku do odczytu i zapisu (kursor ustawiony na początek pliku) w+ - otwarcie pliku do odczytu i zapisu (nadpisuje plik zaraz po otwarciu) a+ - otwarcie pliku do odczytu i zapisu (kursor ustawiony na koniec pliku) Zauważ, że fopen() może zakończyć się niepowodzeniem, nawet jeśli twój program jest całkowicie poprawny. Plik ten może nie istnieć lub może być chroniony przed zapisem. W takich przypadkach fopen() zwróci wskaźnik \\(NULL\\) (czyli \\(0\\)). Oto prosty przykład użycia fopen(): FILE *fp; fp=fopen(&quot;c:\\\\test.txt&quot;, &quot;r&quot;); Ten kod otworzy plik test.txt do odczytu w trybie tekstowym. Aby otworzyć plik w trybie binarnym, musisz dodać b podczas podawania trybu na końcu tego ciągu. Na przykład rb (w trybach czytania i pisania możesz dodać b po znaku plus r+b lub przed rb+). Po zakończeniu pracy z plikiem należy go zamknąć za pomocą funkcji: int fclose(FILE *a_file); fclose zwraca zero, jeśli plik zostanie pomyślnie zamknięty. Przykładem fclose jest: fclose(fp); 12.1 fprintf() Do pracy z tekstem można używać fprintf() i fscanf(), które są podobne do printf() i scanf(), z tym że w fprintf() i fscanf() musisz przekazać wskaźnik FILE* jako pierwszy argument. Na przykład: FILE *fp; fp=fopen(&quot;c:\\\\test.txt&quot;, &quot;w&quot;); fprintf(fp, &quot;Testing...\\n&quot;); 12.2 fgetc() Możliwe jest również odczytywanie (lub zapisywanie) pojedynczego znaku z pliku. Funkcja fgetc() pobiera jako argument wskaźnik FILE* i zwraca wartość int (nie char, jak można by się spodziewać). Pozwala to na odczyt pojedynczego znaku z pliku: int fgetc (FILE *fp); Gdy funkcja wczyta normalny znak z pliku, zwróci wartość odpowiednią do przechowania w unsigned char (liczbę z zakresu od 0 do 255). Gdy nie zostało już nic do odczytu fgetc() zwróci stałą EOF, która oznacza napotkanie końca pliku. 12.3 fputc() Funkcja fputc() pozwala na wpisanie pojedynczego znaku: int fputc( int c, FILE *fp ); Zauważ, że pierwszy argument typu int powinien zawierać wartość z zakresu unsigned char, aby był to prawidłowy znak. Drugi argument to oczywiście uchwyt do pliku do zapisu. Po pomyślnym zakończeniu fputc() zwróci wartość c, a po błędzie zwróci EOF. 12.4 Operacje na plikach binarnych W przypadku pliku binarnego używasz fread() i fwrite(). Deklaracje dla obu są podobne: size_t fread(void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file); size_t fwrite(const void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file); Obie te funkcje służą do radzenia sobie z blokami pamięci, zwykle tablicami i strukturami. Ze względu na operowanie na wskaźnikach void*, można używać tych funkcji ze strukturami danych (zapisywać struktury do pliku lub odczytywać struktury z pliku do pamięci). Funkcja fread() wymaga czterech argumentów. Deklaracja void * ptr; oznacza, że jest to wskaźnik, którego można użyć do przekazania wartości dowolnego typu. Jako pierwszy argument można podać nazwę tablicy lub adres struktury, którą chcesz zapisać do pliku. Drugi argument to rozmiar każdego elementu tablicy (w bajtach). Gdy elementami tablicy są liczby wystarczy użyć sizeof(int). To samo tyczy się struktur i każdego innego typu. Trzecim argumentem jest ilość elementów do odczytania lub zapisania. Ostatnim argumentem jest po prostu wskaźnik do pliku. Funkcja fread() zwraca liczbę odczytanych elementów. Jeśli w pliku znajduje się 30 elementów o rozmiarze 4 bajtów (razem 120 bajtów), a parametry przekazane do funkcji wskazują na to, że ma ich odczytać 100 (czyli 400 bajtów), funkcja fread() zwróci liczbę 30. Do sprawdzenia, czy koniec pliku został osiągnięty, używa się funkcji feof(), która przyjmuje jako parametr wskaźnik FILE* i zwraca wartość true, jeśli osiągnięto koniec pliku. Funkcja fwrite() jest podobna w użyciu do fread(), z tym że w fwrite() zamiast wczytywania do pamięci zapisujesz z pamięci do pliku. Na przykład: FILE *fp; fp=fopen(&quot;c:\\\\test.bin&quot;, &quot;wb&quot;); char x[10]=&quot;ABCDEFGHIJ&quot;; fwrite(x, sizeof(x[0]), sizeof(x)/sizeof(x[0]), fp); "],["zakres-zmiennych-ang.-variable-scope.html", "Rozdział 13 Zakres zmiennych (ang. variable scope)", " Rozdział 13 Zakres zmiennych (ang. variable scope) Kiedy definiujesz zmienną w C, to w zależności od miejsca jej deklaracji będzie miała inny zakres. Co przede wszyskim znaczy, że dostęp do zmiennej jest zawsze ograniczony. W C istnieją 2 typy zmiennych: zmienne globalne zmienne lokalne Zmienna zadeklarowana w funkcji jest zawsze zmienną lokalną: int main(void) { int age = 37; } Zmienne lokalne są dostępne tylko z poziomu funkcji, a kiedy funkcja się kończy, przestają istnieć. Są usuwane z pamięci (z pewnymi wyjątkami). Zmienna zdefiniowana poza funkcją jest zmienną globalną: int age = 37; int main(void) { /* ... */ } Zmienne globalne są dostępne z dowolnej funkcji programu oraz przez cały czas działania programu aż do jego zakończenia. Natomiast zmienne lokalne przestają być dostępne po zakończeniu funkcji, ponieważ są domyślnie alokowane na stosie o ile nie użyjesz alokacji dynamicznej i przydzielisz im pamięć na stercie (z użyciem wskaźników). Ale w tym wypadku musisz samodzielnie zarządzać pamięcią. "],["zmienne-statyczne-ang.-static-variables.html", "Rozdział 14 Zmienne statyczne (ang. static variables)", " Rozdział 14 Zmienne statyczne (ang. static variables) Wewnątrz funkcji można zainicjować zmienną statyczną za pomocą słowa kluczowego static. Powiedziałem ,,wewnątrz funkcji’’, ponieważ zmienne globalne są domyślnie statyczne. Co to jest zmienna statyczna? Jest to zmienna ze słowem kluczowym static i zachowuje swoją wartość w kolejnych wywołaniach funkcji. Rozważmy poniższą funkcję: int incrementAge() { int age = 0; age++; return age; } Wywołując incrementAge() otrzymamy 1 na wyjściu. Kolejne wywołania również zwrócą 1, ponieważ age jest zmienną lokalną i za każdym razem jest inicjowana przez wartość 0. Jeśli jednak ta zmienna będzię zadeklarowana jako statyczna: int incrementAge() { static int age = 0; age++; return age; } to za każdym razem, gdy wywołamy tę funkcję otrzymamy kolejne wartości całkowite: printf(&quot;%d\\n&quot;, incrementAge()); /* 1 */ printf(&quot;%d\\n&quot;, incrementAge()); /* 2 */ printf(&quot;%d\\n&quot;, incrementAge()); /* 3 */ W tym wypadku można pominąć inicjowanie zmiennej age do \\(0\\) w static int age = 0; pisząc static int age;, ponieważ zmienne statyczne są automatycznie inicjowane wartością 0. Możemy również definiować tablice statyczne. W takim przypadku każdy pojedynczy element w tablicy jest inicjowany wartością 0: int incrementAge() { static int ages[3]; ages[0]++; return ages[0]; } "],["zmienne-globalne-ang.-global-variables.html", "Rozdział 15 Zmienne globalne (ang. global variables)", " Rozdział 15 Zmienne globalne (ang. global variables) W tej sekcji chcę omówić różnicę między zmiennymi globalnymi i lokalnymi. Zmienna lokalna jest zdefiniowana wewnątrz funkcji i jest dostępna tylko wewnątrz tej funkcji. Przykład: #include &lt;stdio.h&gt; int main(void) { char j = 0; j += 10; printf(&quot;%u&quot;, j); //10 } dlatego j nie jest dostępne poza główną funkcją. Zmienne globalne definiuje się poza jakąkolwiek funkcją: #include &lt;stdio.h&gt; char i = 0; int main(void) { i += 10; printf(&quot;%u&quot;, i); //10 } Dostęp do zmiennej globalnej ma dowolna funkcja w programie. Dostęp nie jest ograniczony do tylko do odczytu wartości, zmienna może być aktualizowana przez dowolną funkcję. Z tego powodu zmienne globalne są jednym ze sposobów udostępniania danych między funkcjami. Zmienne globalne są zwalniane dopiero po zakończeniu programu. Zapamiętaj więc, że główną różnicą w przypadku zmiennych lokalnych jest to, że pamięć przydzielona zmiennym jest zwalniana każdorazowo po zakończeniu funkcji. "],["definicje-typów-ang.-type-definitions.html", "Rozdział 16 Definicje typów (ang. type definitions)", " Rozdział 16 Definicje typów (ang. type definitions) Słowo kluczowe typedef w C umożliwia zdefiniowanie nowych typów. A więc możemy tworzyć własne typy zmiennych, używając następującej składni: typedef istniejący_typ NOWY_TYP; Nowy typ jest zwykle, zgodnie z konwencją, dużymi literami, ale nie jest to powszechne w języku C++. Umożliwia to łatwiejsze rozróżnienie i łatwiejsze rozpoznanie typu. Na przykład możemy zdefiniować nowy typ NUMBER, który jest tak naprawdę typem int: typedef int NUMBER; następnie możesz zdefiniować zmienną NUMBER: NUMBER one = 1; Dlaczego zamiast tego nie użyć wbudowanego typu int? Cóż, typedef staje się naprawdę użyteczny dopiero wtedy, gdy występuje z typami wyliczeniowymi i strukturami. W C++ zastosowanie jest o wiele szersze i pozwala na zachowanie znacznie większej czytelności kodu. "],["wyliczeniowy-typ-danych-ang.-enumerated-type.html", "Rozdział 17 Wyliczeniowy typ danych (ang. enumerated type)", " Rozdział 17 Wyliczeniowy typ danych (ang. enumerated type) Używając słów kluczowych typedef i enum możemy zdefiniować typ, który może mieć jedną lub drugą wartość. Jest to jedno z najważniejszych zastosowań słowa kluczowego typedef. Oto składnia typu wyliczeniowego: typedef enum { //...values } TYPENAME; Typ enum jest zwykle, zgodnie z konwencją, dużymi literami. Oto prosty przykład: typedef enum { monday, tuesday, wednesday, thursday, friday, saturday, sunday } WEEKDAY; A teraz prosty program, który wykorzystuje typ wyliczeniowy: #include &lt;stdio.h&gt; typedef enum { monday, tuesday, wednesday, thursday, friday, saturday, sunday } WEEKDAY; int main(void) { WEEKDAY day = monday; if (day == monday) { printf(&quot;It&#39;s monday!&quot;); } else { printf(&quot;It&#39;s not monday&quot;); } } Każdy element w enum jest w rzeczywistości liczbą całkowitą. W tym przykładzie monday to 0, tuesday to 1 itd. Oznacza to, że warunkiem mogłoby być if (day == 0) zamiast if (day == monday) ale kod znacznie łatwiej jest zrozumieć widząc ,,konkretne’’ nazwy, więc jest to bardzo wygodne. "],["struktury-ang.-structures.html", "Rozdział 18 Struktury (ang. structures)", " Rozdział 18 Struktury (ang. structures) Za pomocą słowa kluczowego struct możemy tworzyć złożone struktury danych przy użyciu podstawowych typów C. Struktura to zbiór wartości różnych typów. Tablice w C są ograniczone do jednego typu, więc struktury mogą okazać się bardzo interesujące w wielu przypadkach użycia. Składnia: struct &lt;structname&gt; { //...variables }; Przykład: struct person { int age; char *name; }; Możesz od razu zadeklarować zmienną globalną o tym typie, dodając nazwę po nawiasie zamykającym przed średnikiem: struct person { int age; char *name; } flavio; lub kilka: struct person { int age; char *name; } flavio, people[20]; W tym przypadku zadeklarowałem zmienną o nazwie flavio i tablicę 20 elementową o nazwie people. Możemy również deklarować zmienne w każym miejscu w kodzie, używając następującej składni: struct person { int age; char *name; }; struct person flavio; Możemy również zainicjalizować wartości w strukturze w czasie deklaracji: struct person { int age; char *name; }; struct person flavio = { 37, &quot;Flavio&quot; }; a po zdefiniowaniu struktury możemy uzyskać dostęp do zawartych w niej wartości za pomocą operatora . (kropki): struct person { int age; char *name; }; struct person flavio = { 37, &quot;Flavio&quot; }; printf(&quot;%s, age %u&quot;, flavio.name, flavio.age); Możemy również zmodyfikować wartości: struct person { int age; char *name; }; struct person flavio = { 37, &quot;Flavio&quot; }; flavio.age = 38; Struktury są bardzo przydatne, ponieważ możemy przekazywać je jako parametry funkcji lub jako wartość zwracaną z funkcji. To jest w C jedyny sposób na zwrócenie z funkcji kilku wartości (właściwie to jednej wartości, czyli struktury, która może zawierać nieograniczoną ilość zmiennych). Każda zmienna musi mieć swoją etykietę/nazwę. Ważne jest, aby pamiętać, że struktury przekazywane są przez kopie, oczywiście o ile nie przekazujesz wskaźnika do struktury. Używając typedef, możemy uprościć kod podczas pracy ze strukturami. Przykład: typedef struct { int age; char *name; } PERSON; Struktura, którą tworzymy za pomocą typedef nazwijmy, zgodnie z konwencją, wielkimi literami. Teraz możemy zadeklarować nowe zmienne PERSON w następujący sposób: PERSON flavio; i możemy zainicjować je podczas deklaracji w następujący sposób: PERSON flavio = { 37, &quot;Flavio&quot; }; "],["parametry-wiersza-poleceń-ang.-command-line-parameters.html", "Rozdział 19 Parametry wiersza poleceń (ang. command line parameters)", " Rozdział 19 Parametry wiersza poleceń (ang. command line parameters) W programach C może okazać się konieczne pobranie parametrów z wiersza poleceń. W tym celu należy zmodyfikować wywołanie funkcji main() z: int main(void) na int main (int argc, char *argv[]) argc jest liczbą całkowitą zawierającą liczbę parametrów podanych w wierszu poleceń. argv to tablica ciągów znaków. Kiedy uruchamiamy program podając parametry, umieszczane są jako argumenty w tych dwóch parametrach. Zauważ, że w tablicy argv zawsze jest co najmniej jeden element, a mianowicie nazwa programu. Weźmy za przykład kompilator C, którego używamy do uruchamiania naszych programów, w następujący sposób: gcc hello.c -o hello Gdyby to był nasz program, argc wynosiłby 4, a argv byłby tablicą zawierającą: gcc hello.c -o hello Napiszmy program, który wypisuje otrzymane argumenty: #include &lt;stdio.h&gt; int main (int argc, char *argv[]) { for (int i = 0; i &lt; argc; i++) { printf(&quot;%s\\n&quot;, argv[i]); } } Jeśli nazwą naszego programu jest hello i uruchamiamy go w następujący sposób: ./hello, otrzymamy: ./hello Jeśli przekażemy jakieś losowe parametry, takie jak: ./hello a b c, otrzymamy: ./hello a b c Ten system doskonale sprawdza się w przypadku dość prostych programów. W przypadku bardziej złożonych potrzeb istnieją powszechnie używane biblioteki, takie jak getopt. "],["pliki-nagłówkowe-ang.-header-files.html", "Rozdział 20 Pliki nagłówkowe (ang. header files)", " Rozdział 20 Pliki nagłówkowe (ang. header files) Proste programy można umieścić w jednym pliku ale gdy twój program się powiększa staje się to niepraktyczne. Możesz przenieść jego składowe do osobnych plików .c, a następnie w plikach nagłówkowych umieścić jedynie deklaracje. Plik nagłówka wygląda jak zwykły plik C, z tym że kończy się na .h zamiast .c. Zamiast implementacji twoich funkcji i innych części programu, przechowuje wyłącznie deklaracje. Użyłeś już plików nagłówkowych, kiedy używałeś funkcji printf() lub innej funkcji I/O: #include &lt;stdio.h&gt; #include jest dyrektywą preprocesora. Preprocesor załącza plik stdio.h ze standardowej biblioteki, ponieważ używasz nawiasów ostrokątnych. Aby dołączyć własne pliki nagłówkowe używasz cudzysłowów: #include &quot;myfile.h&quot; Powyższa dyrektywa wyszuka plik myfile.h w bieżącym folderze. Możesz także użyć ścieżki do pliku: #include &quot;myfolder/myfile.h&quot; Spójrzmy na przykład. Ten program oblicza lata od danego roku: #include &lt;stdio.h&gt; int calculateAge(int year) { const int CURRENT_YEAR = 2020; return CURRENT_YEAR - year; } int main(void) { printf(&quot;%u&quot;, calculateAge(1983)); } Załóżmy, że chcę przenieść funkcję calcAge() do osobnego pliku. Tworzę plik calc_age.c: int calculateAge(int year) { const int CURRENT_YEAR = 2020; return CURRENT_YEAR - year; } Oraz plik calc_age.h, w którym umieszczam prototyp funkcji, który jest taki sam jak funkcja w pliku .c za wyjątkiem bloku kodu: int calculateAge(int year); Teraz w głównym pliku .c możemy przejść i usunąć definicję funkcji calcAge(), a także zaimportować nagłówek calc_age.h, który udostępni funkcję calcAge(): #include &lt;stdio.h&gt; #include &quot;calculate_age.h&quot; int main(void) { printf(&quot;%u&quot;, calculateAge(1983)); } Nie zapominaj, że aby skompilować program złożony z wielu plików, musisz wymienić je wszystkie w wierszu poleceń, w następujący sposób: gcc -o main main.c calculate_age.c W przypadku bardziej złożonych programów plik Makefile jest niezbędny do poinformowania kompilatora o sposobie kompilacji programu. Jednak struktura takiego pliku nie jest związana z programowaniem w C i nie będzie opisana w tym dokumencie. "],["preprocesor.html", "Rozdział 21 Preprocesor 21.1 Kompilacja warunkowa (ang. conditional compilation) 21.2 Definicje 21.3 Makra 21.4 #ifdef 21.5 Predefiniowane stałe symboliczne (ang. predefined symbolic constants)", " Rozdział 21 Preprocesor Preprocesor jest narzędziem, które bardzo pomaga nam podczas programowania w C. Jest częścią standardu C, podobnie jak język, kompilator i biblioteka standardowa. Analizuje nasz program i upewnia się, że kompilator otrzyma wszystkie potrzebne rzeczy przed kontynuowaniem procesu. Co robi preprocesor w praktyce? Na przykład wyszukuje wszystkie pliki nagłówkowe zawarte w dyrektywach #include. Zamienia także każdą stałą zdefiniowaną za pomocą #define i zastępuje ją rzeczywistą wartością. Ale to tylko wierzchołek możliwości preprocesora. Wspomniałem o tych dwóch operacjach, ponieważ są one najczęstsze. Preprocesor może zrobić znacznie więcej. Czy zauważyłeś, że #include i #define mają # na początku? Jest to charakterystyczne dla wszystkich dyrektyw preprocesora. Jeśli linia zaczyna się od #, zajmuje się nią preprocesor. 21.1 Kompilacja warunkowa (ang. conditional compilation) Jedną z rzeczy, które możemy zrobić, to użyć instrukcji warunkowych, aby zmienić sposób kompilacji naszego programu, w zależności od wartości wyrażenia. Na przykład możemy sprawdzić, czy stała DEBUG wynosi \\(0\\): #include &lt;stdio.h&gt; const int DEBUG = 0; int main(void) { #if DEBUG == 0 printf(&quot;I am NOT debugging\\n&quot;); #else printf(&quot;I am debugging\\n&quot;); #endif } Stała DEBUG jest zdefiniowana wartością \\(1\\) w momencie gdy program zostaje skompilowany do analizy jego działania poprzez tzw. debugowanie. 21.2 Definicje #define pozwalająca zdefiniować: stałą, funkcję słowo kluczowe, makro Poniżej znajduje się przykład definicji stałych: #define VALUE 1 #define PI 3.14 #define NAME &quot;Flavio&quot; Kiedy używamy NAME, PI lub VALUE w naszym programie, preprocesor zastępuje podane nazwy ich wartością w miejscu w którym zostały użyte. Stałe symboliczne są bardzo przydatne, ponieważ możemy nadawać nazwy wartościom bez tworzenia zmiennych w czasie kompilacji. 21.3 Makra Za pomocą #define możemy również zdefiniować makro. Różnica między makrem, a stałą symboliczną polega na tym, że makro może zaakceptować argument i zazwyczaj zawiera kod, podczas gdy stała symboliczna jest wartością: #define POWER(x) ((x) * (x)) Zwróć uwagę na nawiasy wokół argumentów: nie jest to konwencja ani coś wynikające ze składni, jest to po prostu dobra praktyka stosowana, aby unikać problemów podczas zastępowania makra w procesie wstępnej kompilacji. Następnie możemy użyć go w naszym kodzie w następujący sposób: printf(&quot;%u\\n&quot;, POWER(4)); //16 Dużą różnicą w stosunku do funkcji jest to, że makra nie mają typów argumentów ani typu wartości zwracanej, co może być przydatne w specyficznych przypadkach. Zapamiętaj jednak, że zawartość makr jest wstawiana w miejscu ich użycia co dla poprzedniego przykładu sprawia, że po zakończeniu pracy preprocesora kompilowany dalej kod wygląda następująco: printf(&quot;%u\\n&quot;, ((4) * (4))); //16 21.4 #ifdef Za pomocą #ifdef możemy sprawdzić, czy stała symboliczna lub makro zostało zdefiniowane: #include &lt;stdio.h&gt; #define VALUE 1 int main(void) { #ifdef VALUE printf(&quot;Value is defined\\n&quot;); #else printf(&quot;Value is not defined\\n&quot;); #endif } Do sprawdzenia czy stała symboliczna lub makro jest niezdefiniowane możemy użyć #ifndev. Możemy również użyć #if defined (równoznaczne z #ifdef) oraz #if !defined (równoznaczne z #ifndev). Często zdarza się, że określone bloki kodu powinny lub nie powinny zostać dołączone do programu w zależności od parametrów kompilacji, systemu operacyjnego czy platformy sprzętowej. Szablon: #if 0 #endif Przykład: #define DEBUG 0 #if DEBUG //code only sent to the compiler //if DEBUG is not 0 #endif W powyższym przykładzie można tymczasowo zapobiec kompilacji kodu w bloku wykorzystując stałą symboliczną DEBUG (ustawienie \\(1\\) powoduje załączenie, a #define DEBUG 0 powoduje, że kod nie będzie dostępny w czasie kompilacji). 21.5 Predefiniowane stałe symboliczne (ang. predefined symbolic constants) Preprocesor w czasie kompilacji definiuje szereg stałych symbolicznych, które można użyć. W wypadku C, ich nazwy rozpoczynają się dwoma znakami podkreślenia i kończą dwoma znakami podkreślenia. Poniżej przedstawiam najbardziej popularne i wykorzystywane stałe symboliczne, np. do wykrywania błędów w programie: __LINE__ zawiera aktualny numer linii w pliku __FILE__ zawiera aktualną nazwę pliku __DATE__ zawiera aktualną datę w formacie MM dd yyyy (miesiąc dzień rok) __TIME__ zawiera aktualny czas kompilacji w formacie hh:mm:ss (godzina:minuta:sekunda) "],["unie-ang.-unions.html", "Rozdział 22 Unie (ang. unions)", " Rozdział 22 Unie (ang. unions) Unia to specjalny typ danych dostępny w C, który pozwala przechowywać różne typy danych w tej samej lokalizacji pamięci. Możesz zdefiniować unie z wieloma elementami, ale tylko jeden może przechowywać wartość w danym momencie. Unie zapewniają efektywny sposób wykorzystania tego samego fragmentu pamięci. Aby zdefinicjować unie należy użyć odpowiedniego schematu. Definiowanie unii jest podobne do definiowania struktury. Instrukcja union definiuje nowy typ danych z więcej niż jednym elementem. union Data { int i; float f; char str[20]; } data; Zmienna typu Data może przechowywać liczbę całkowitą, liczbę zmiennoprzecinkową lub ciąg znaków. Oznacza to, że jedna zmienna, tzn. jeden obszar pamięci, może być używana do przechowywania wielu typów danych. Możesz używać dowolnych wbudowanych lub zdefiniowanych przez użytkownika typów danych w unii, w zależności od wymagań. Pamięć zajmowana przez unię zawsze będzie taka, jak największy jej element. Na przykład w powyższym fragmencie kodu typ Data zajmie \\(20\\) bajtów w pamięci, ponieważ najwiekszym elementem jest ciąg znaków, który tyle zajmuje. Poniższy kod pokazuje całkowity rozmiar pamięci zajmowany przez data: printf( &quot;Memory size occupied by data : %d\\n&quot;, sizeof(data)); Gdy powyższy kod zostanie skompilowany i wykonany, daje następujący wynik: Memory size occupied by data : 20 Poniżej przedstawiam bezsensowny, ale jednoznacznie podkreślający najważniejszą cechę unii, przykład: data.i = 10; data.f = 220.5; strcpy( data.str, &quot;C Programming&quot;); printf( &quot;data.i : %d\\n&quot;, data.i); printf( &quot;data.f : %f\\n&quot;, data.f); printf( &quot;data.str : %s\\n&quot;, data.str); Gdy powyższy kod zostanie skompilowany i wykonany, daje następujący wynik: data.i : 1917853763 data.f : 4122360580327794860452759994368.000000 data.str : C Programming Widzimy tutaj, że wartości i oraz f uległy uszkodzeniu, ponieważ ostatnie przypisanie (skopiowanie łańcucha znaków) zajęło cały fragment pamięci, dlatego jedynie wartość str jest wypisywana poprawnie. Teraz spójrzmy jeszcze raz na ten sam przykład, jednak tym razem będziemy używać tylko jednej zmiennej naraz (to główny cel istnienia unii): data.i = 10; printf( &quot;data.i : %d\\n&quot;, data.i); data.f = 220.5; printf( &quot;data.f : %f\\n&quot;, data.f); strcpy( data.str, &quot;C Programming&quot;); printf( &quot;data.str : %s\\n&quot;, data.str); Gdy powyższy kod zostanie skompilowany i wykonany, daje następujący wynik: data.i : 10 data.f : 220.500000 data.str : C Programming W tym wypadku wszystkie zmienne są wypisywane poprawnie, ponieważ tylko jeden z typów jest używany jednocześnie. "],["pola-bitowe-ang.-bit-fields.html", "Rozdział 23 Pola bitowe (ang. bit fields)", " Rozdział 23 Pola bitowe (ang. bit fields) Standard C99 dla języka C obsługuje zmienne typu bool, jednak w odróżnieniu od C++, aby użyć bool, należy załączyć w kodzie plik nagłówkowy stdbool.h. Poniższa struktura zawiera szereg zmiennych PRAWDA / FAŁSZ o typie bool zgrupowanych w strukturze o nazwie status: struct { bool widthValidated; bool heightValidated; } status; Ta struktura wymaga 2 bajtów miejsca w pamięci, a w rzeczywistości chcemy przechowywać 0 lub 1 (zajmujące jeden bit, czyli \\(1/8\\) bajtu) w każdej ze zmiennych. Język programowania C oferuje lepszy sposób wykorzystania przestrzeni pamięci w takich sytuacjach. W przypadku zmiennych zajmujących mniej niż 1 bajt używa się pól bitowych. Możesz zdefiniować szerokość tych zmiennych, nie muszą one zajmować tylko jednego bitu jak dla wartości logicznej. Na przykład powyższą strukturę można przepisać w następujący sposób: struct { unsigned char widthValidated : 1; unsigned char heightValidated : 1; } status_flags; Powyższa struktura wymaga 1 bajtu pamięci dla zmiennej status_flags, ale do przechowywania wartości zostaną użyte tylko 2 bity. Wielkość struktury w bajtach zawsze będzie liczbą całkowitą. Sprawdźmy: printf( &quot;Memory size occupied by status : %d\\n&quot;, sizeof(status)); printf( &quot;Memory size occupied by status_flags : %d\\n&quot;, sizeof(status_flags)); Gdy powyższy kod zostanie skompilowany i wykonany, daje następujący wynik: Memory size occupied by status : 2 Memory size occupied by status_flags : 1 Zmienne zdefiniowane z predefiniowaną szerokością nazywane są polami bitowymi. Pole bitowe może zawierać więcej niż jeden bit. Na przykład, jeśli potrzebujesz zmiennej do przechowywania wartości od 0 do 7, możesz zdefiniować pole bitowe o szerokości 3 bitów w następujący sposób: struct { unsigned char age : 3; } Age; Powyższa definicja struktury instruuje kompilator C, że zmienna wieku będzie używać tylko 3 bity do przechowywania wartości. Jeśli spróbujesz zapisać do zmiennej age wartość liczbową przekraczającą 3 bity dostaniesz ostrzeżenie od kompilatora, a wartość wpisywana zostanie obcięta do trzech najmniej znaczących bitów. Tą sytuację ukazuje następujący przykład: #include &lt;stdio.h&gt; #include &lt;string.h&gt; struct { unsigned char age : 3; } Age; int main( ) { printf( &quot;Sizeof( Age ) : %d\\n&quot;, sizeof(Age) ); Age.age = 7; printf( &quot;Age.age : %d\\n&quot;, Age.age ); Age.age = 8; printf( &quot;Age.age : %d\\n&quot;, Age.age ); Age.age = 9; printf( &quot;Age.age : %d\\n&quot;, Age.age ); return 0; } Gdy powyższy kod zostanie skompilowany, skompiluje się z ostrzeżeniem, a po uruchomieniu wygeneruje następujący wynik Sizeof( Age ) : 4 Age.age : 7 Age.age : 0 Age.age : 1 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
